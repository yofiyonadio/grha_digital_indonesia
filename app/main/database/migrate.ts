import { Models, Interfaces, Enums, Utils as U, Schema, ENV } from '../../registry'

//import * as Models from '../../model'


class Migrate {

    createDB() {
        return `CREATE DATABASE "${ENV.DB_NAME}" WITH ENCODING 'UTF8';`
    }

    createSCHEMA() {
        return Object.values(Schema).map(schema => `CREATE SCHEMA IF NOT EXISTS "${schema}"`).join(';')
    }

    createENUMS() {
        const ress = Object.values(Models).map(record => record.default.columns().map((column: Interfaces.TableInteface) => {
            if (column.type !== 'SERIAL' && Array.isArray(column.type)) {
                const _enum_name = `"enum_${record.default.table().name}_${column.name}"`
                const _drop = `DROP TYPE IF EXISTS ${_enum_name} CASCADE;`
                const _create = `CREATE TYPE ${_enum_name} AS ENUM(${Object.values(column.type).map(enums => `'${enums}'`).join(',')});`
                if (column.delete) {
                    return _drop
                } else {
                    return _drop + _create
                }
            }
            return ''
        }).join(';')).join(';')
        return ress
    }

    createTABLES() {
        return Object.values(Models).map(record => `CREATE TABLE IF NOT EXISTS "${record.default.table().schema}"."${record.default.table().name}" ()`).join(';')
    }

    createCOLUMNS() {
        return Object.values(Models).map(record => record.default.columns().map((column: Interfaces.TableInteface) => {
            const table_name = `"${record.default.table().schema}"."${record.default.table().name}"`
            const identity = column.identity ? 'GENERATED BY DEFAULT AS IDENTITY' : ''
            const sequence_name = 'sequence_' + record.default.table().name
            const sequence_default = column.sequence ? `DEFAULT nextval('${sequence_name}')` : ''
            const sequence = column.sequence ? `CREATE SEQUENCE IF NOT EXISTS "${sequence_name}";` : ''
            const _enum_name = `"enum_${record.default.table().name}_${column.name}"`
            if (!column.delete) {
                return sequence + `ALTER TABLE ${table_name} ADD COLUMN IF NOT EXISTS "${column.name}" ${Array.isArray(column.type) ? _enum_name : column.type} ${sequence_default} ${identity} ${column.nullable ? 'NULL' : 'NOT NULL'};`
            } else {
                return sequence.replace('CREATE', 'DROP') + `ALTER TABLE "${record.default.table().schema}"."${record.default.table().name}" DROP COLUMN IF EXISTS "${column.name}" CASCADE`
            }
        }).join(';')).join(';')
    }

    createDATATYPES() {
        return Object.values(Models).map(record => record.default.columns().map((column: Interfaces.TableInteface) => {
            if (!column.delete) {
                if (column.type !== 'SERIAL') {
                    const _schema_name = `"${record.default.table().schema}"`
                    const _table_name = `"${record.default.table().name}"`
                    const _column_name = ` "${column.name}"`
                    const _enum_name = `"enum_${record.default.table().name}_${column.name}"`
                    const _default = column.default ? 'DEFAULT ' + (column.default as any instanceof Date || typeof column.default === 'string' && column.default !== 'NOW()' ? U.SQLString(column.default) : column.default) : ''
                    return `ALTER TABLE ${_schema_name}.${_table_name} ALTER COLUMN ${_column_name} TYPE ${Array.isArray(column.type) ? _enum_name : column.type};` + (column.default ? `ALTER TABLE ${_schema_name}.${_table_name} ALTER COLUMN ${_column_name} SET ${_default};` : '') + (`ALTER TABLE ${_schema_name}.${_table_name} ALTER COLUMN ${_column_name} ` + (column.nullable ? 'DROP NOT NULL;' : 'SET NOT NULL;'))
                }
                return ''
            }
            return ''
        }).join(';')).join(';')
    }

    createINDEXING() {
        return Object.values(Models).map(record => {
            return record.default.columns().map(col => {
                if (!col.delete) {
                    const _schema = record.default.table().schema
                    const _table = record.default.table().name
                    const _index_name = `"indexing_UNIQUE_${_schema}_${_table}_${col.name}"`
                    const _primary_name = `"indexing_PRIMARY_${_schema}_${_table}_${col.name}"`
                    const _target = `"${_schema}"."${_table}"`
                    const drop_unique = `DROP INDEX IF EXISTS "${_schema}".${_index_name} CASCADE`
                    const create_unique = `CREATE UNIQUE INDEX ${_index_name} ON ${_target} ("${col.name}")`
                    const drop_primary = `ALTER TABLE ${_target} DROP CONSTRAINT IF EXISTS ${_primary_name} CASCADE`
                    const create_primary = `ALTER TABLE ${_target} ADD CONSTRAINT ${_primary_name} PRIMARY KEY ("${col.name}")`

                    const Q = []
                    if (!col.unique) {
                        Q.push(drop_unique)
                    } else {
                        Q.push(drop_unique)
                        Q.push(create_unique)
                    }
                    if (!col.primary) {
                        Q.push(drop_primary)
                    } else {
                        Q.push(drop_primary)
                        Q.push(create_primary)
                    }
                    return Q.join(';')
                }
                return ''
            }).join(';')
        }).join(';')
    }

    createRELATIONS() {
        return Object.values(Models).map((record: any) => {
            try {
                const schema = record.default.table().schema
                const table = record.default.table().name
                return record.default.relation().map((rel: Interfaces.RelationInterface) => {
                    return `
                    ALTER TABLE "${schema}"."${table}"
                    DROP CONSTRAINT IF EXISTS FK_${(rel.ref_table as any).table().name}_and_${table};
                    ALTER TABLE "${schema}"."${table}"
                    ADD CONSTRAINT FK_${(rel.ref_table as any).table().name}_and_${table} FOREIGN KEY ("${rel.foreign_column}")
                    REFERENCES "${(rel.ref_table as any).table().schema}"."${(rel.ref_table as any).table().name}" ("${rel.ref_column}")
                    ON DELETE CASCADE
                    ON UPDATE CASCADE
                    `
                }).join(';')
            } catch (e) {
                return ''
            }
        }).join(';')
    }

    createSEEDER() {
        return Object.values(Models).map(record => {
            try {
                const truncate = `TRUNCATE TABLE "${record.default.table().schema}"."${record.default.table().name}" RESTART IDENTITY CASCADE`
                return [ENV.DB_MIGRATE_CLEAN === 'true' ? truncate : '', ...(record as any).default.seeder().map((data: any, i: number) => {
                    const _id = !data.id ? i + 1 : data.id
                    const _target = `"${record.default.table().schema}"."${record.default.table().name}"`
                    const _columns = Object.keys(data).map(col => U.SQLObject(col)).join(', ')
                    const _inserts = Object.values(data).map(val => U.SQLValue(val))
                    const _updates = Object.keys(data).map(col => U.SQLObject(col) + ' = ' + U.SQLValue(data[col]))
                    const Q = `INSERT INTO ${_target} (${_columns})
                    VALUES (${_inserts})
                    ON CONFLICT DO NOTHING;` + `UPDATE ${_target} SET ${_updates} WHERE id = ${_id}`
                    return Q
                })].join(';')
            } catch {
                return ''
            }
        }).join(';')
    }
}

export default new Migrate()